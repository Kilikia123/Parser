# Описание решения

***Условие задачи:*** Необходимо реализовать эффективный алгоритм поиска по строке в очень большом текстовом файле. Файл загружается один раз, потом происходит большое количество запросов на поиск.

***Алгоритм решения:*** По сути наша задача заключается в том, чтобы найти позиции вхождения строки в текст. Есть много алгоритмов, которые нам позволяют это сделать: алгоритм Рабина-Карпа, Кнута-Мориса-Прата и т.д. Однако нам пользователь дает много запросов (строк), поэтому эти алгоритмы в данной ситуации слабы. В данной задаче я решил использовать "Суффиксный автомат". Рассмотрим алгоритм и поймем за какое время он работает:
1. Вначале строим суффиксный автомат по нашему тексту. Это работает за O(len(text)). Но это не обычный суффиксный автомат. В каждой вершине мы будем хранить окончание первого вхождения (в моем коде это поле first_entry в структуре Node).
2. Чтобы найти индекс первого вхождения, мы запускаем обход в глубину, где переход по ребрам осуществляется по буквам. Тогда, если мы можем проложить полный путь, дойдя до какой-то вершины, то ответом будет first_entry - len(pattern) + 1. Однако нам нужно еще учесть те вершины, к которым мы можем дойти по суф-ссылкам. В сумме один запрос работает за O(len(pattern) + len(result)), где result - результирующий массив, состоящий из индексов вхождения.

***Документация:*** 


## Пример ввода и вывода
Рассмотрим следующий текст, относительно которого будут запросы по поиску строк:

![text](https://user-images.githubusercontent.com/65976385/161101135-2908df9f-93de-4e2e-b4c9-3d21cb7d937f.jpg)

Затем мы подаем полный путь этого файла, как аргумент:

![step2](https://user-images.githubusercontent.com/65976385/161101883-69ad4ff7-da2f-449d-8b67-ea883f5acb34.jpg)

Вводим данные:

![step3](https://user-images.githubusercontent.com/65976385/161102978-0693a98a-5215-454e-8a80-9dd1c2212fad.jpg)

Получаем результат:

![step4](https://user-images.githubusercontent.com/65976385/161103317-37eeb05e-5e9d-45bd-ae28-7937f6a81af2.jpg)
